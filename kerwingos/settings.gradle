//pluginManagement {
//    repositories {
//        google {
//            content {
//                includeGroupByRegex("com\\.android.*")
//                includeGroupByRegex("com\\.google.*")
//                includeGroupByRegex("androidx.*")
//            }
//        }
//        mavenCentral()
//        gradlePluginPortal()
//    }
//}
//dependencyResolutionManagement {
//    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
//    repositories {
//        google()
//        mavenCentral()
//    }
//}

rootProject.name = "KerwinGo"
include ':app'
include ':libraries:lib1'
include ':libraries:lib2'
include ":pluginLibs:plugin1"
include ":aptLibs:router-annotation"
include ":processorLibs:router-processor"

println "setting.g + ${rootProject.projectDir}"
gradle.addBuildListener(new BuildAdapter(){
    @Override
    void settingsEvaluated(Settings settings) {
        super.settingsEvaluated(settings)
        //执行setting.gradle
        println "lifecycle 初始完成"
    }

    @Override
    void projectsEvaluated(Gradle gradle) {
        super.projectsEvaluated(gradle)
        //执行各个目录下build.gradle脚本 来完成project对象的配置，
        // 并且根据项目自己的配置，构建任务依赖关系图，以便下一阶段执行。

        //拿到所有子project 实例
        dfs(gradle.rootProject)
        println "lifecycle 配置完成"
    }

    private void dfs(Project project) {
        File buildFile = new File(project.projectDir, 'build.gradle')
        if (!buildFile.exists()) {
            buildFile = new File(project.projectDir, 'build.gradle.kts')
        }
        if (project != gradle.rootProject && buildFile.exists()) {
            println "子工程路径${project.projectDir}"
            return
        }
        project.childProjects.each {
            dfs(it.value)
        }
    }

    @Override
    void buildFinished(BuildResult result) {
        super.buildFinished(result)
        //把配置阶段生成的依赖任务图，依次去执行
        println "lifecycle 构建结束"
    }
})

//把本次构建的任务所有名字都打印
//gradle.taskGraph.beforeTask { task ->
//    println("[all-task] " + task.name)
//}
//任务依赖 实际过程靠任务的链路去执行 如果有多个相同task 都会执行


//plugin：
//真正的构建行为 来自任务； 真正的任务来自哪呢？1 自己自定义task编辑工程java代码
//2 方法1 不合理，插件负责封装以及提供gradle运行期间需要的task, 在工程中依赖某个
//插件后，提高复用性。复用代码，使得构建脚本高度模块化。
//有些插件并没有提供一些功能，可以使用自定义插件。
//比如 android 插件就是 根据java 插件来的。添加了编译资源 打包apk等功能

//gradle 插件分为 二进制插件(jar包比如android插件) 和 脚本插件（独立gradle脚本）。

//二进制使用步骤 1. 根目录找到 buildScript的 dependencies, 告诉gradle 插件版本号和到哪里找
//2.在具体的子工程中应用插件 3 配置插件参数 比如android 插件

//插件： 建立插件工程  配置插件入库实现插件  发布到maven库



//是的，当您在 Android Studio 中点击 "Sync Project with Gradle Files" 按钮（通常简称为 "Sync" 按钮）时，Android Studio 会执行以下操作来同步和配置您的项目：
//
//读取项目结构：首先，Android Studio 会读取您的项目目录结构，特别是 settings.gradle 文件，以确定包含哪些模块（通常是 app 模块和其他可能的库模块）。
//
//执行 build.gradle 脚本：然后，Android Studio 会开始执行每个模块目录下的 build.gradle 文件。这些文件定义了模块的构建配置，包括依赖项、编译选项、插件设置等。
//
//配置 Project 对象：在执行这些 build.gradle 脚本时，Gradle 会创建并配置一个 Project 对象。这个对象包含了项目的所有配置信息，并且可以通过 Gradle API 进行访问和修改。
//
//下载依赖项：Gradle 会检查 build.gradle 文件中定义的依赖项，并下载任何尚未下载的依赖项。这些依赖项可能包括库、工具或其他构建时所需的资源。
//
//解析插件：如果 build.gradle 文件中使用了任何 Gradle 插件（如 Kotlin 的 kapt 插件），Gradle 会下载并解析这些插件。
//
//生成构建文件：基于 build.gradle 文件的配置，Gradle 会生成必要的构建文件（如中间文件、缓存文件等），以便后续构建过程可以使用。
//
//错误和警告：如果在执行 build.gradle 脚本或配置 Project 对象时遇到任何问题（如配置错误、依赖项冲突等），Gradle 会报告相应的错误或警告。
//
//同步完成：一旦所有 build.gradle 脚本都成功执行并且 Project 对象被正确配置，Android Studio 就会显示同步完成的消息，并且您就可以继续进行构建、运行或调试您的项目了。
//
//总之，点击 "Sync Project with Gradle Files" 按钮是确保您的 Android 项目与 Gradle 构建系统保持同步的重要步骤。


// sync点击： Gradle 读取文件修改(一般文件build.gradle改动)Project 和 Settings对象的参数和配置，同时执行无关紧要的task prepareKotlinBuildScriptModel 意思下
// ./gradlew 命令： 在上述步骤走一遍后，执行task!


