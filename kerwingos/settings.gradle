//pluginManagement {
//    repositories {
//        google {
//            content {
//                includeGroupByRegex("com\\.android.*")
//                includeGroupByRegex("com\\.google.*")
//                includeGroupByRegex("androidx.*")
//            }
//        }
//        mavenCentral()
//        gradlePluginPortal()
//    }
//}
//dependencyResolutionManagement {
//    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
//    repositories {
//        google()
//        mavenCentral()
//    }
//}

rootProject.name = "KerwinGo"
include ':app'
include ':libraries:lib1'
include ':libraries:lib2'
include ":pluginLibs:plugin1"

println "setting.g + ${rootProject.projectDir}"
gradle.addBuildListener(new BuildAdapter(){
    @Override
    void settingsEvaluated(Settings settings) {
        super.settingsEvaluated(settings)
        //执行setting.gradle
        println "lifecycle 初始完成"
    }

    @Override
    void projectsEvaluated(Gradle gradle) {
        super.projectsEvaluated(gradle)
        //执行各个目录下build.gradle脚本 来完成project对象的配置，
        // 并且根据项目自己的配置，构建任务依赖关系图，以便下一阶段执行。

        //拿到所有子project 实例
        dfs(gradle.rootProject)
        println "lifecycle 配置完成"
    }

    private void dfs(Project project) {
        File buildFile = new File(project.projectDir, 'build.gradle')
        if (!buildFile.exists()) {
            buildFile = new File(project.projectDir, 'build.gradle.kts')
        }
        if (project != gradle.rootProject && buildFile.exists()) {
            println "子工程路径${project.projectDir}"
            return
        }
        project.childProjects.each {
            dfs(it.value)
        }
    }

    @Override
    void buildFinished(BuildResult result) {
        super.buildFinished(result)
        //把配置阶段生成的依赖任务图，依次去执行
        println "lifecycle 构建结束"
    }
})
//任务依赖 实际过程靠任务的链路去执行 如果有多个相同task 都会执行


//plugin：
//真正的构建行为 来自任务； 真正的任务来自哪呢？1 自己自定义task编辑工程java代码
//2 方法1 不合理，插件负责封装以及提供gradle运行期间需要的task, 在工程中依赖某个
//插件后，提高复用性。复用代码，使得构建脚本高度模块化。
//有些插件并没有提供一些功能，可以使用自定义插件。
//比如 android 插件就是 根据java 插件来的。添加了编译资源 打包apk等功能

//gradle 插件分为 二进制插件(jar包比如android插件) 和 脚本插件（独立gradle脚本）。

//二进制使用步骤 1. 根目录找到 buildScript的 dependencies, 告诉gradle 插件版本号和到哪里找
//2.在具体的子工程中应用插件 3 配置插件参数 比如android 插件

//插件： 建立插件工程  配置插件入库实现插件  发布到maven库
