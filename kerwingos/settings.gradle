//pluginManagement {
//    repositories {
//        google {
//            content {
//                includeGroupByRegex("com\\.android.*")
//                includeGroupByRegex("com\\.google.*")
//                includeGroupByRegex("androidx.*")
//            }
//        }
//        mavenCentral()
//        gradlePluginPortal()
//    }
//}
//dependencyResolutionManagement {
//    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
//    repositories {
//        google()
//        mavenCentral()
//    }
//}

rootProject.name = "KerwinGo"
include ':app'
include ':libraries:lib1'
include ':libraries:lib2'
include ":pluginLibs:plugin1"
include ":aptLibs:router-annotation"
include ":processorLibs:router-processor"
include ':libraries:route-runtime'
enableFeaturePreview("VERSION_CATALOGS") //为了使用transform -> 变成gradle 7.2 -> 出现问题 ->加入这行//https://stackoverflow.com/questions/69082017/caused-by-org-gradle-api-invalidusercodeexception-using-dependency-catalogs-re

println "setting.g + ${rootProject.projectDir}"
gradle.addBuildListener(new BuildAdapter(){
    @Override
    void settingsEvaluated(Settings settings) {
        super.settingsEvaluated(settings)
        //执行setting.gradle
        println "lifecycle 初始完成"
    }

    @Override
    void projectsEvaluated(Gradle gradle) {
        super.projectsEvaluated(gradle)
        //执行各个目录下build.gradle脚本 来完成project对象的配置，
        // 并且根据项目自己的配置，构建任务依赖关系图，以便下一阶段执行。

        //拿到所有子project 实例
        dfs(gradle.rootProject)
        println "lifecycle 配置完成"
    }

    private void dfs(Project project) {
        File buildFile = new File(project.projectDir, 'build.gradle')
        if (!buildFile.exists()) {
            buildFile = new File(project.projectDir, 'build.gradle.kts')
        }
        if (project != gradle.rootProject && buildFile.exists()) {
            println "子工程路径${project.projectDir}"
            return
        }
        project.childProjects.each {
            dfs(it.value)
        }
    }

    @Override
    void buildFinished(BuildResult result) {
        super.buildFinished(result)
        //把配置阶段生成的依赖任务图，依次去执行
        println "lifecycle 构建结束"
    }
})

//把本次构建的任务所有名字都打印
gradle.taskGraph.beforeTask { task ->
    println("[all-task] " + task.name)
}
//任务依赖 实际过程靠任务的链路去执行 如果有多个相同task 都会执行


//plugin：
//真正的构建行为 来自任务； 真正的任务来自哪呢？1 自己自定义task编辑工程java代码
//2 方法1 不合理，插件负责封装以及提供gradle运行期间需要的task, 在工程中依赖某个
//插件后，提高复用性。复用代码，使得构建脚本高度模块化。
//有些插件并没有提供一些功能，可以使用自定义插件。
//比如 android 插件就是 根据java 插件来的。添加了编译资源 打包apk等功能

//gradle 插件分为 二进制插件(jar包比如android插件) 和 脚本插件（独立gradle脚本）。

//二进制使用步骤 1. 根目录找到 buildScript的 dependencies, 告诉gradle 插件版本号和到哪里找
//2.在具体的子工程中应用插件 3 配置插件参数 比如android 插件

//插件： 建立插件工程  配置插件入库实现插件  发布到maven库



//是的，当您在 Android Studio 中点击 "Sync Project with Gradle Files" 按钮（通常简称为 "Sync" 按钮）时，Android Studio 会执行以下操作来同步和配置您的项目：
//
//读取项目结构：首先，Android Studio 会读取您的项目目录结构，特别是 settings.gradle 文件，以确定包含哪些模块（通常是 app 模块和其他可能的库模块）。
//
//执行 build.gradle 脚本：然后，Android Studio 会开始执行每个模块目录下的 build.gradle 文件。这些文件定义了模块的构建配置，包括依赖项、编译选项、插件设置等。
//
//配置 Project 对象：在执行这些 build.gradle 脚本时，Gradle 会创建并配置一个 Project 对象。这个对象包含了项目的所有配置信息，并且可以通过 Gradle API 进行访问和修改。
//
//下载依赖项：Gradle 会检查 build.gradle 文件中定义的依赖项，并下载任何尚未下载的依赖项。这些依赖项可能包括库、工具或其他构建时所需的资源。
//
//解析插件：如果 build.gradle 文件中使用了任何 Gradle 插件（如 Kotlin 的 kapt 插件），Gradle 会下载并解析这些插件。
//
//生成构建文件：基于 build.gradle 文件的配置，Gradle 会生成必要的构建文件（如中间文件、缓存文件等），以便后续构建过程可以使用。
//
//错误和警告：如果在执行 build.gradle 脚本或配置 Project 对象时遇到任何问题（如配置错误、依赖项冲突等），Gradle 会报告相应的错误或警告。
//
//同步完成：一旦所有 build.gradle 脚本都成功执行并且 Project 对象被正确配置，Android Studio 就会显示同步完成的消息，并且您就可以继续进行构建、运行或调试您的项目了。
//
//总之，点击 "Sync Project with Gradle Files" 按钮是确保您的 Android 项目与 Gradle 构建系统保持同步的重要步骤。


// sync点击： Gradle 读取文件修改(一般文件build.gradle改动)Project 和 Settings对象的参数和配置，同时执行无关紧要的task prepareKotlinBuildScriptModel 意思下
// ./gradlew 命令： 在上述步骤走一遍后，执行task!



//在Gradle构建系统中，gradle build和gradle assemble（或其对应的gradlew build和gradlew assemble，当使用Gradle Wrapper时）是两个常见的命令，用于项目的构建和打包过程，但它们之间存在一些区别：
//
//任务范围：
//
//gradle build：执行完整的构建过程，这通常包括编译源代码、运行测试（如果有定义的话）、生成文档（如果配置了文档生成任务）以及打包输出（如JAR、APK等）1234。简而言之，build任务会执行项目中定义的所有构建步骤，确保最终生成的是一个完整且经过验证的构建产物2。
//gradle assemble：专注于生成构建产物，即打包过程。它不会执行测试或生成文档，只是将编译的源代码、资源文件和其他必要的文件打包成一个或多个输出文件（如JAR、APK等）23。
//输出：
//
//两者都会生成构建产物，但gradle build还会生成其他与构建过程相关的输出，如测试报告、文档等（如果配置了这些任务）3。
//依赖关系：
//
//gradle build依赖于其他任务，如编译任务（compileJava等）、测试任务（test）和打包任务（jar、apk等）124。
//gradle assemble通常只依赖于编译任务和打包任务2。
//使用场景：
//
//当你想要确保代码的质量、执行所有必要的检查和测试，并生成完整的构建产物时，应该使用gradle build3。
//如果你只是想快速生成一个构建产物，而不关心测试或文档等其他输出，那么可以使用gradle assemble3。
//时间效率：
//
//由于gradle build执行了更多的任务，因此它通常需要更长的时间来完成3。
//gradle assemble通常更快，因为它只执行必要的打包任务3。
//总之，gradle build和gradle assemble在Gradle构建系统中都是有用的命令，但它们的范围、输出、依赖关系和使用场景有所不同。根据你的具体需求选择适当的命令。

